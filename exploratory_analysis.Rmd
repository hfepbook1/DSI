---
title: "Exploratory analysis using `group_by`"
output:
  html_document: 
    toc: true
    toc_float: true
---

Data sets can frequently be partitioned into meaningful groups based on the variables they contain. Making this grouping explicit allows the computation of numeric summaries within groups, which in turn facilitates quantitative comparisons. 

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

library(tidyverse)
```

## Some slides

<script async class="speakerdeck-embed" data-id="77a37cf3dcb945a9abd2e09439158d07" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<div style="margin-bottom:5px"> <strong> <a href="https://speakerdeck.com/jeffgoldsmith/dsi-exploratory-analysis" title="Exploratory analysis" target="_blank">Exploratory Analysis</a> </strong> from <strong><a href="https://speakerdeck.com/jeffgoldsmith" target="_blank">Jeff Goldsmith</a></strong>. </div><br>


## Example

Stay in the same project. Use a similar dataset -- weather from three stations last year -- and add a variable `month`.

```{r weather_data_create, cache = TRUE}
library(rnoaa)

weather = 
  meteo_pull_monitors(c("USW00094728", "USC00519397", "USS0023B17S"),
                      var = c("PRCP", "TMIN", "TMAX"), 
                      date_min = "2016-01-01",
                      date_max = "2016-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY", 
                      USC00519397 = "Waikiki_HA",
                      USS0023B17S = "Waterhole_WA"),
    tmin = tmin / 10,
    tmax = tmax / 10,
    month = lubridate::floor_date(date, unit = "month")) %>%
  select(name, id, date, month, everything())
weather
```

### `group_by`

Central idea here is grouping by a variable or collection of variables. Adds a partition to your data and allows you to apply functions within those partitions. 

summarizing within groups

mutating within groups

Sometimes you have a grouping and you need to remove it; use `ungroup()`.

### Counting things

As an intro to summarize, let's count the number of observations in each month.

```{r}
weather %>%
  group_by(month) %>%
  summarize(n = n())
```

Note this returns a dataframe that includes the grouping variable and the summary.

Could use `count()`, if you remember it exists. It's a handy specialized function.

```{r}
weather %>%
  count(month)
```

Can count both total observations and distinct occurances of another variable

```{r}
weather %>%
  group_by(month) %>%
  summarize(n_obs = n(),
            n_days = n_distinct(date))
```

### General summaries

Lots of functions return a single number; many of these are standard statistical quantities: `mean()`, `median()`, `var()`, `sd()`, `mad()`, `IQR()`, `min()`, and `max()`. To use these, you'll also have to indicate the variable to which they apply. 

```{r}
weather %>%
  group_by(month) %>%
  summarize(mean_tmax = mean(tmax),
            median_tmax = median(tmax))
```

You can also group by more than one variable if you need more refined summaries. 

```{r}
weather %>%
  group_by(name, month) %>%
  summarize(mean_tmax = mean(tmax),
            median_tmax = median(tmax))
```

The fact that this is producing a dataframe is important -- you can incorporate grouping and summarizing within broader analysis pipelines. For example, we can take the previous example and plot it. 

```{r}
weather %>%
  group_by(name, month) %>%
  summarize(mean_tmax = mean(tmax),
            median_tmax = median(tmax)) %>%
  ggplot(aes(x = month, y = mean_tmax, color = name)) + 
    geom_point() + geom_line() + 
    theme(legend.position = "bottom")
```

### Grouped `mutate`

In contrast to summarize, we can create new variables based on our grouping. 

Suppose we wanted to see the change in max temperature within each month. 

```{r}
weather %>%
  group_by(name) %>%
  mutate(change_tmax = tmax - mean(tmax)) %>% 
  ggplot(aes(x = date, y = change_tmax, color = name)) + 
    geom_point() 
```


### Window functions

Here we've used mean() to compute the mean within each group (a single number) and taken the difference. Window functions, in contrast, use `n` inputs and return `n` outputs, and the outputs depend on all the inputs. You're most likely to need ranking functions and offsets, which we illustrate below.

Find temperature ranking within month.
```{r}
weather %>%
  group_by(name, month) %>%
  mutate(temp_ranking = min_rank(tmax))
```

Retain the coldest day within each month:
```{r}
weather %>%
  group_by(name, month) %>%
  filter(min_rank(tmax) < 2)
```

Retain the warmest day within each month:
```{r}
weather %>%
  group_by(name, month) %>%
  filter(min_rank(desc(tmax)) < 2)
```

In both of these, we've skipped a mutate statement that would store the ranking and gone straight to filtering based on the result. 


Find the day-by-day change in temp within each station over the year.

```{r}
weather %>%
  group_by(name) %>%
  mutate(temp_change = tmax - lag(tmax))
```

Which stations have the most variability in temperature? What's the largest one-day increase?
```{r}
weather %>%
  group_by(name) %>%
  mutate(temp_change = tmax - lag(tmax)) %>%
  summarize(temp_change_sd = sd(temp_change, na.rm = TRUE),
            temp_change_max = max(temp_change, na.rm = TRUE))
```

Note that we included `na.rm = TRUE` -- the lag on the first day isn't defined.


### Limitations

Can only perform simple operations within a group. This is very high ceiling -- you can do tons of stuff using simple operations when you combine them with groupings, mutates, filtering, etc -- but it is a ceiling. Later we'll see how to aggregate data in a more general way, and how to perform complex operations on these sub-datasets.

## Other materials

http://stat545.com/block010_dplyr-end-single-table.html#group_by-is-a-mighty-weapon

http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise http://r4ds.had.co.nz/exploratory-data-analysis.html

https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html

