---
title: "List Columns and Bootstrapping"
output:
  html_document: 
    toc: true
    toc_float: true
---

R's data structures, especially data frames, are surprisingly flexible. This is useful when the "observations" you want to store become more complex than single values; for example, each row many contain a few scalar observations as well a complete data set. In these cases, _list columns_ are an appropriate column type, and `map` functions provide a way to interact with those columns.

Bootstrapping is a popular resampling-based approach to statistical inference, and is helpful when usual statistical methods are intractable or inappropriate. The idea is to draw repeated samples from your original sample _with replacement_, thereby approximating the repeated sampling framework. Using list columns to store bootstrap samples is natural and provides a "tidy" approach to resampling-based inference.

This is the third module in the [Iteration](topic_iteration.html) topic; the relevant slack channel is [here](https://p8105-fall2017.slack.com/messages/C7WC2UPT7).

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)
```


## Some slides

<script async class="speakerdeck-embed" data-id="ee17524f046c49a58cec601fb98bb72d" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>
<div style="margin-bottom:5px"> <strong> <a href="https://speakerdeck.com/jeffgoldsmith/dsi-tidy-text" title="Tidy Text" target="_blank">Tidy Data</a> </strong> from <strong><a href="https://speakerdeck.com/jeffgoldsmith" target="_blank">Jeff Goldsmith</a></strong>. </div><br>


## Example

I'll write code for today's content in a new R Markdown document called `listcols_and_bootstrapping.Rmd` in the `example_iteration` directory / repo. The code chunk below loads the usual packages.

```{r}
library(tidyverse)

theme_set(theme_bw())
theme_update(legend.position = "bottom")

set.seed(1)
```

Things are gonna get a little weird.

### Weather data

Remember the weather data?

```{r weather_data_create, cache = TRUE}
library(rnoaa)

weather = 
  meteo_pull_monitors(c("USW00094728", "USC00519397", "USS0023B17S"),
                      var = c("PRCP", "TMIN", "TMAX"), 
                      date_min = "2016-01-01",
                      date_max = "2016-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY", 
                      USC00519397 = "Waikiki_HA",
                      USS0023B17S = "Waterhole_WA"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

The station name and id are constant across remaining observations. For that reason, we could organize a new DF with three rows -- one for each station -- and a column that includes everything else. This is what the nest function does. 

```{r}
weather = 
  nest(weather, date:tmin)

weather
```

The `data` column is a *list column* -- on it's own, it's a list. This is similar to the name column being a character column, becuase it contains a character vector.

Inpecting the data column gives an idea of what's going on.

```{r}
weather$data
```

We can also access specific entries in the list column, which (in this case) are data frames. 

```{r}
weather$data[[1]]
```

Nesting columns can help with data organization / understanding by masking stuff you're less concerned about right now and clarifying the things you are concerned about. It also simplifies the use of analytic approaches across levels of a higher variable. 

Also possible to reverse if your list col is contains data frames. 

```{r}
unnest(weather)
```


### operations on list columns

It would be great to be able to manipulate list columns, but usual operations (like `mean` or `recode`) often don't apply to the entries in a list column. 

write a quick function

```{r}
weather_lm = function(df) {
  lm(tmax ~ tmin, data = df)
}
```

try it on one df

```{r}
weather_lm(weather$data[[1]])
```

use map to apply it everywhere

```{r}
map(weather$data, weather_lm)
```

note you can use an "anonymous" function using `map`'s syntax.

```{r}
map(weather$data, ~lm(tmax ~ tmin, data = .x))
```

result of map is a list; can store results as a new list column.

```{r}
weather = 
  weather %>% 
  mutate(models = map(data, weather_lm))

weather
```

this is great! keeps track of everything

what about other things -- summarizing, for example. that's easy with `broom::tidy`. that produces a df; let's look at a quick example. 


```{r}
lm(tmax ~ tmin, data = weather$data[[1]]) %>% 
  broom::tidy()
```

we can remove other stuff then unnest. since tidy produces a data frame, unnesting this gives nicely-structured output. 

```{r}
weather = 
  weather %>% 
  mutate(results = map(models, broom::tidy)) %>% 
  select(-data, -models) %>% 
  unnest()

weather
```

This is really handy!!

Note that this isn't, generally speaking, the right way to analyze data like these. We have datasets nested within stations -- for that kind of data, a hierarchical / random effects model is more appropriate. But this is a quick and easy way to get useful answers in an exploratory way.


### Instacart data

same process but faster


### bootstrapping

Why bootstrap

simulate data coming from a model with increasing variance

```{r}
set.seed(10)

n_samp = 250

df_1 = tibble(
  x = rnorm(n_samp, 1, 1),
  error = rnorm(n_samp, 0, 1),
  y = 2 + 3 * x + error
)

df_2 = df_1 %>% 
  mutate(
  error = error * .75 * x,
  y = 2 + 3 * x + error
)

bind_rows(
  mutate(df_1, data = "df_1"),
  mutate(df_2, data = "df_2")
) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  stat_smooth(method = "lm") +
  facet_grid(~data) 

lm(y ~ x, data = df_1) %>% summary()
lm(y ~ x, data = df_2) %>% summary()
```

point out that OLS estimates will understate variance. 

bootstrapping can help here (note: WLS would also work, and might be better).

write a function to do resampling from the population.


### BS samples as list col

```{r}
boot_sample = function(df) {
  sample_frac(df, replace = TRUE)
}

boot_straps = data_frame(
  strap_number = 1:100,
  strap_sample = rerun(100, boot_sample(df_2))
)

boot_straps
```

some quick checks

```{r}
boot_straps %>% 
  mutate(mean_y = map_dbl(.x = strap_sample, ~mean(.x$y) ) )

boot_straps %>% 
  filter(strap_number %in% 1:3) %>% 
  unnest() %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  facet_grid(~strap_number) 
```


fit models; extract results


```{r}
boot_straps %>% 
  mutate(models = map(strap_sample, ~lm(y ~ x, data = .x) ),
         results = map(models, broom::tidy)) %>% 
  select(-strap_sample, -models) %>% 
  unnest() %>% 
  group_by(term) %>% 
  summarize(boot_se = sd(estimate))
```



make some plots


```{r}
boot_straps %>% 
  unnest() %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_line(aes(group = strap_number), stat = "smooth", method = "lm", se = FALSE, alpha = .2, color = "blue") +
  geom_point(data = df_2)
```


### `bootstrap`

Show how this works using `bootstrap()`

```{r}
library(modelr)

boot_straps = 
  df_2 %>% 
  bootstrap(n = 100)

boot_straps$strap[[1]]
as_data_frame(boot_straps$strap[[1]])
```

```{r}

df_2 %>% 
  bootstrap(n = 100) %>% 
  mutate(models = map(strap, ~lm(y ~ x, data = .x) ),
         results = map(models, broom::tidy)) %>% 
  select(-strap, -models) %>% 
  unnest() %>% 
  group_by(term) %>% 
  summarize(boot_se = sd(estimate))

```

## Other materials


* http://r4ds.had.co.nz/many-models.html
* https://stackoverflow.com/questions/45101045/why-use-purrrmap-instead-of-lapply 
* https://jennybc.github.io/purrr-tutorial/
* https://drsimonj.svbtle.com/k-fold-cross-validation-with-modelr-and-broom
* http://rpubs.com/dgrtwo/cv-modelr
* https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html
* https://github.com/tidyverse/broom/blob/master/vignettes/bootstrapping.Rmd
* https://github.com/tidyverse/modelr

The code that I produced working examples in lecture is [here](ZZZZZ).
